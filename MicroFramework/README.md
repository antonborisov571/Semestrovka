# MicroFramework

### ***Как использовать?***

Подключаете к проекту шаблонизатор, ORM и сам framework. 

Далее создаёте контроллеры (создаёте обычные классы и помечаете их аттрибутом ```[Controller("Роут для страницы")]```)

В этих контроллерах создаёте методы помеченные аттрибутами ```[HttpGET("Роут от контроллера")]```. 

Сделайте так чтобы ваши методы возращали ```IControllerResult``` и возращайте что-то что реализует данный интерфейс.

### ***Как это выглядит в программе?***

```cs
[Controller()]
// если ничего не передавать в конструктор, то роут будет браться из имени класса и будет написан строчные буквами
class TopUsers
{
    [HttpGET("/")]
    public async Task<IControllerResult> GetTopUsers()
    {
        var accounts = (await MyORM.Instance.Select<Model.Account>()).OrderByDescending(x => x.Reputation).Take(100);
        return new View("topusers", accounts);
    }
}
// т.е. по роуту /topusers/ я получу топ пользователей
```

### ***Модельки***

Создайте классы помеченные аттрибутом ```[Table("Название модели")]```

### ***Что там со View?***

Создайте папку View (необязательно View, вы можете поменять имя папки с шаблонами в settings.json) и там создавайте файлы с расширением ".tpl". Исходя из этого можно сделать вывод, для того чтобы пример выше работал нужно чтобы в папке View был файл "topusers.tpl".  

### ***Как запустить?***

```cs
using (var server = new HttpServer())
{
    server.UseControllers();
    server.Start();
}
```

## Замечание 

В качестве моделек очень удобно передавать объект Anonymous type, просто в шаблоне обращаться к его свойствам.
